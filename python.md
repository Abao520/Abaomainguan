说Python的起源：1989年的圣诞节，吉多--也就是Python的创始人在阿姆斯特丹打发时间的时候决心开发一个新的解释程序，作为ABC语言的继承，python是用C语言实现的，并且能够调用C语言的库文件。什么是ABC语言？就是专门为非程序员开发的一门语言，吉多参与这个语言的设计，但最后这门语言并没有开发出来，吉多认为是非开放造成的，所以就想开发一个来继承，为什么叫Python呢？其实英语好的同学应该知道Python是蟒蛇的意思，吉多起这个名字纯属是因为他喜欢bbc播放的一部电视剧--Monty python's Flying Circus(蒙瑅.派森的飞行马戏团)，所以一般来说大佬的思想方式和行动力都是非常强的，说开发就开发，于是我们现在异常火爆的python，就在1991诞生了第一个python的解释器了，python解释器是用C语言实现的，并且能够调用C语言的库文件。这里我要给大家普及一下解释器的基本知识

解释器：
   我们的计算机是不能够直接理解除了机器语言以外的其他语言，什么是机器语言，就是0101010101...他是通过线路的高低电平来实现的，所以我们在设计程序的时候，必须要把我们所写的语言翻译成机器语言，计算机才能懂得我们发出的指令，才能执行程序，编译器就起到这么一个作用，将程序语言翻译为机器语言，

  编译器有两种方式翻译，解释和编译，他们运行的结果为解释型语言和编译型语言，编译型语言最常见的也就是我们的C语言，解释型语言常见的就是我们学习的python，主要的区别在于翻译的时间点不同，解释器是一行一行的解释然后丢给CPU执行，编译型语言就要统一编译，一起执行，编译型语言执行速度快，因为他最后生成的可执行文件就是我们机器能够直接识别的语言，在执行这个文件的时候没有任何的翻译动作，由于解释性语言还要重头来一行一行的翻译、执行，所以速度上就慢了，但是从跨平台的角度来说，解释型语言能更好的使用，如果我们的编译器是在win上的，他生成的可执行文件为.exe，放在liunx和其他的系统上就不能够使用了，所以从这个角度来说的话，python这类的语言更好的在其他平台上开发，万事万物都有利弊，所以要根据个人的习惯来选择语言。

python语言的设计目标有以下几点：
一门简单直观且和主要的竞争者一样强（主流的语言能做的，python也能做）
开源，所有人都可以为他做贡献
代码像英语那样容易理解（不是说你英语好才能学习python 2333 是让代码容易读，和开发没关系的）
适用于短期开发的日常任务，同一个程序，python的代码量是Java的1/5（就是说写程序快，代码简洁，还比较少）

python的设计哲学
此哲学不是彼哲学（洞door次door大），首先是优雅，意思就是让每一句代码看起来漂亮，工整，其次是明确，就是每句代码都要明确的说是是什么，最后一个是简单，在有很多语句都可以表示的情况下，python选择了最易懂的那句不选那些花里胡哨的东西，其他语言可能说语法越多越灵活，但是很多时候大家都不想胡花里胡哨，好好的写一句不好吗，为啥选其他麻烦的呢，就跟一个q就能带走，你非要q接摸眼w还要加一个r闪小九头是一个道理。  

python是一个完全面向对象的语言，在python中所有的函数，模块，字符串都是对象，在python中一切都是对象，面向对象是一种思维方式，也是一门程序设计技术。

什么叫面向对象？举个例子，我们在做一件事情的时候我们自己没法做，就需要其他人帮忙来做，这个其他人就是这个其他人，解决复杂的问题就要要找多个对象，也就是多个其他人各司其职，来一起完成，最终完成需求。在python中我们要输出一个字符串，我们自己是没有办法告诉电脑我们要做什么的，我们只好找print()这个函数来解决，在这之中，print（）这个函数就是对象，我们解决问题就是面向对象解决问题。在python的标准库中，还提供了许多额外功能，例如系统管理，网络通信，文字处理等等等等，你还可以自己开发自己的模块，也可以在社区里自己添加模块来丰富自己的python，比如后文讲的的Requests模块。

讲了这么多我们再来看看python的优缺点，任何事物都有两面性，python的优点包括：简单易学、免费开源、面向对象、丰富的库、可扩展性，其中开源保证了我们所有学习python的人可以更好的为这门语言舔砖加瓦，我们除了可以用python来进行编写代码，还可以用其他高级语言来写我们程序中的核心代码，既提高了速度还保证了核心算法不泄露，是一种很好的保护措施，python的缺点就是运行速度没有其他高级语言快，毕竟是解释型语言，和其他编译型比起来确实不快，国内的市场比较小，这不是说python没人学，只是相对于其他语言来说。学习的时候没有中文的文献资料，所以我还是希望国内的大佬还是能够进尽快的出一些资料来供我们参考。

我们再来了解一下程序执行的原理：
首先是计算机的是三个核心硬件：
1：CPU 也就是我们的中央处理器，他是一个超大规模的集成电路，适用于处理数据和运算的
2：内存  内存是临时存储数据的，断电以后数据就会消失，读取速度很快，空间小，造价高
3：硬盘  是永久存储数据的东西，读取速度慢，空间大，造价低
然后我们来了解原理：
一个程序运行之前，程序是保存在硬盘中，当要运行的时候，系统会把程序复制到内存中，然后靠CPU来执行内存中的程序代码，所以要运行程序是要先把程序加载到内存中的，说白了就是为了让执行的速度快，内存比硬盘快太多了。 
Python程序执行的原理是先把Python的解释器复制到内存中，然后解释器告诉CPU怎么来翻译Python的代码，CPU翻译以后（翻译成010101的机器语言）就可以运行程序了，Python的解释器很小，不会占用多大的空。

这就是python的基础内容，有些地方没讲到，因为篇幅有限，想要知道更多的话就希望大家可以等我的下一篇chat，我会继续和大家深入了解关于python的东西，接下来我给大家讲一下关于python中的Requests库的使用，后面的文章可能需要一点基础的同学才能够看的懂。

python的源程序概念：
   Python的源程序就是一个特殊格式的文本文件，所以我们可以使用任意的文本编辑器来写Python的代码，也就是说你直接用记事本写源程序也可以，但是python的源程序的文件拓展名是.py 如果你用记事本写就注意一下细节。

我们首先认识第一个函数—print()：它和C语言中的printf()函数是一样的，是将我们的引号引起来的内容输出到屏幕上，例如print("hello,python")就会在终端上打印hello,word 这就是这个函数的用法。
我们一般不会直接在终端写代码，这时候引入一个新的词语-解释器运行，就是把代码写好了以后再调用解释器来解释你写的代码，这是常见的用解释器的方式来解释我们的代码，一般的步骤是这样的：
1：你用你的编辑器来写代码，然后保存为.py的文件
2：打开终端，输入：python 加你的文件名字
这样就能够用终端运行你的python文件了，这也就是解释器运行代码的意思
以下是我的例子：我们输入print（"hello"）,然后保存为test.py 打开终端输入 python test.py 回车，我们可以看到终端上下显示了hello的单词
其次我们也要了解交互式运行，所谓交互就是打一行代码，解释一行代码，我们怎么进入这个模式呢？很简单，直接在终端输入python就行，前提是要有python的环境。这种方式比较适合学习少量代码和测试局部代码，不适合很多代码并且不能保存。输入exit()和ctrl+d 退出，我们可以输入ipytho你使用ipython的shell，比官方的好用，支持补全，自动缩进，以及各种功能。最后就是我们使用的IDE（集成开发环境）例如pycham。我们可以直接在里面完成我们所有的日常开发，非常好用，还能断点、单步执行。具体的使用方法我就不在赘述


接下来我们来认识一下程序的错误(BUG),什么叫程序错误？就是我们编写的程序不能正常执行，或者执行的结果不是我们所期望的结果，这些就叫做程序错误，这是非常常见的，很多同学看到这可能就会想：为什么要认识错误，我们的程序不就是要没有错误才对嘛？是的我们的程序不能有错误，但本可能保证每一个人都不会犯错误，就算是有很多年开发的老手，都有手误的时候，所以认识错误是必要的的，一般来说现在初学的人常犯的错误有以下几个：
1：手误，这是最常见的错误了，单词拼写错误，很多人在写程序的时候就没有有个好习惯，中英混用，前面是中文的左括号，后面接一个英文的右括号，一运行就错，关键是这两个符号还不容易区分，所以我们在写的时候一定要记住，不要中英文混用，其次就是写程序的时候老是忘了符号补全，一般就是前面有引号，后面就没有引号，丢三落四，所以我们在写程序的时候一定要好好的写，不要着急，还有就是能手打的代码你就安安心心的手打，不要Ctrl+c，ctrl+V，这会把你对代码的感情消磨掉，一打代码你就觉的生，人家写代码是一提到就能够把代码打出来，你还要百度那个函数怎么拼写，这是大忌不能犯的。
2：对学习过的知识理解还存在不足，当我们学的越来越多的时候，我们就容易将前面所学的一些东西遗忘，或者对前面所学的东西不熟悉，不懂得一些细节上的问题，我们在学习的时候一定要记住不能够囫囵吞枣，要慢慢的消化，理解每一个知识点。
3：对语言还有需要学习和提升的地方。
错误不能够避免，但是我们也会在错误中成长

一些常见的错误代码可以去百度，例如NameError是名称错误，也就是拼写函数的错误，syntaxError是语法错误，也就是你的语法问题。要了解常见的报错的回显的意思，一般的编译器会给你一个提示，比如你的函数输错了，他的颜色不会和正确代码一样
一般我们怎么避免错误的产生呢？首先我们手误的错误，在写的时候就仔细看看有没有拼写错误，还有就是不能够一行写多个代码，例如print(),一般来说python解释器能够识别一个print，但是后面的他就不认识了，python的解释器告诉过我们一行只能完成一个动作，我们上次chat也讲过，python的哲学就是要代码漂亮和工整，一行写多个也不好看对吧。还有就是缩进错误(UnexpectedErtror),就是我们在写代码的时候多按了空格，或者少按了空格，让代码不好看，虽然这个严格的要求有点难受，但是也让我们养成了好习惯，让我们的代码工整漂亮，如果非要按空格的话我建议最好用TAB键来代替空格来用。

注释，我们有两种注释办法，一种是单行注释，还有多行注释（块注释），注释的作用是为了让我们能够更好地记住我们写的代码。
#是单行注释的方法，python解释器在发现一个#以后会直接将后面的看做说明文字，他会直接跳过，直接读取下一条代码，我们在一代码之后换行加一个#就能写出我们所想描述的信息，或者直接在后面添加也是一样的，注释不会影响我们的代码,为了让我们的代码更加规范，我们最好在#后加一个空格。
""" 添加我们需要添加的注释内容""" 这是多行注释的方式，在其中的语句是不会读取的，全部都解释掉。注释一般是复杂的不易懂得才添加注释，每一句都注释就很麻烦。
接下来我们看看Python的运算符，运算符就是我们的加减乘除等一系列算数运算符号，加减和原来的一样，其他的由以下的代替使用：
乘法使用* 
除法使用/ 如果不能整除的使用//来取得这次运算的整数部分
除法去余使用 %
幂次方使用** 例如2的5次方 用Python表示就是 2**5 
我们也可以使用字符串使用* 例如print("hello")*10 就是打印10次hello
关于运算级和小学是一样的，乘方>乘除>加减，可以使用()来调整算数的优先

我们接下来看一看变量的定义，上次chat我们提到过程序执行的原理是在硬盘复制到内存然后解释执行，用qq来打一个比方，qq的登陆原理是先把程序拿到内存中，然后我们开始输入账号和密码，点击登录，但是在我们还没有点击的时候，我们的数据在哪儿呢？这时候的数据是在内存中，因为我们的程序也在内存中，那么我们的程序是怎么样存储这些数据的？这里就提到我们的变量，就是存储在变量中，简单的来说就是程序是来处理数据的，而变量就是来存储数据的，当然变量是存在于内存中的。

所以我们接下来讲解变量的基本使用：
1：变量的定义：
  在Python中，每个变量在使用的时候都需要赋值，变量赋值以后才会被创建，我们使用"="来给变量赋值，变量的名字我们自己来决定，但是千万不要设置什么a等于XX，真的是一个非常不好的习惯。我们创建好变量以后，在交互中可以直接输入变量名输出我们的数据，如果在解释器中就要利用print(你创建的变量名) 进行输出。

变量第一次出现是定义，第二次的话就是直接使用，不会再定义相同的变量。
变量类型：
1.我们创建了变量以后，会包括：
2.变量名称
3.变量保存的数据
4.变量储存数据的类型
5.变量的地址
我们主要看数据的类型有两大类，数字和非数字型
定义是不需要指明类型的，python的解释器就会自动推断出变量的准确类型，不同的数据类型是不同的。

数字型有：
  整数类型(int)，
  bool型(bool):简单的来说就是只有真(Ture)或假(False)的值，Python是把真或假用1和0表示
  浮点型(float):就表示是一个小数类型，python判断浮点和整型主要是看有没有小数点。
复数型：这是用于科学计算，一般是用不到的，例如微积分

非数字型：
   字符串型(str)，在Python中的定义字符型只要将变量值用""括起来。
   列表：
   元祖：
   字典：
在ipython中我们可以用type()来查看我们的变量是什么类型，具体用法是type(我们的变量名)，我们就可以把这个类型输出出来，就知道这个变量的类型，其中我们整型有两个类型（在Python2中有区分）long和int 一个是长整型（long）一个是整型（int）

相同数字型变量的计算：数字型的计算直接加减乘除就行，我们的bool型的Ture就相当于1，False就是0，所以也可以直接计算。

字符串变量之间使用+来生成新的字符，例如name_first=张，name_last=三
我们使用加号把他们连起来则：name_first+name_last计算的结果就为张三，这就是字符串的加法。利用*就可以重复指定的字符多少次，例如："hello"*10我们就可以得到10个hello。数字型和字符串之间是不能进行其他计算的，但是可以将数字转换为字符然后拼接。

接下来我们来看看input()这个函数：
  我们知道print（）函数是一个输出函数，有输出就有输入，我们要让用户输入变量的值，所以我们就要用到input()这个函数，这个函数是让我们用户输入的，一般来说用输入的函数，就要用输出的函数，我这里给大家科普一下函数的意思，所谓的函数就是一个提前准备好的功能（其他人或者自己写好的代码，后面会提到自己定义函数）可以直接使用，例如我们的print() 函数，我们看起来只有这么短短的一行，但是在计算机内部要经过很多步骤，汇编语言输出一句话的所有需要的东西全部打包放好在这个print()函数里，我们就不用那么麻烦了，只需要进行很简便的操作。这就是函数的意思。
我们接下来体会一下input()函数的使用：
  一般的格式为 input("你得提示语句") 例如：input("输入你的手机号")当我们在运行的时候终端就会提示这样一段话，然后我们就可以输入我们的值，这时候是没有定义变量的，所以这个值是不会被保存，我们需要定义一个变量例如：name = input("输入你的名字：")，和上面一样终端会提示你输入你的名字，当你输入以后就会把你输入的值，放在我们的name变量里，这就是input()的使用方法。那么我们输入的变量是什么类型呢？在input()函数的输入的任何内容都是字符串，我们如果想要输入的类型改变，只能通过强制转换，例如强制转换为数字型：name = int(input("输入你的名字：")),这个时候我们输入的内容就是一个数字类型了，同理还可以用其他的例如float()来变成浮点型，具体的强制转换函数就请大家百度

变量的格式化输出：我们在使用python是输出函数时，希望同时输出我们定义的变量的数据，这个时候就需要我们使用到格式化输出，打个比方：
我们定义变量：name = input("输入你的名字：")
输出你好欢迎：print("你好，欢迎")
但是这样不是很完美，如果我们需要输出："
你好，欢迎+我们输入的变量值"应该怎么做呢？这时我们就要利用格式化输出来达到我们的目的，我们构建输出语句:print("你好，欢迎%s",name )
我们就能够看到这条代码不仅输出了你好欢迎，还输出了我们的变量值，这样就将我们的代码变得更加人性化，其中包含%的字符串叫做 格式化字符串，%和不同的字符连用，不同的类型需要不同的格式化字符。
    输出的格式为：例如:name = "小明"
                                      print("你好，我的名字叫%s 请多多关照"%name)
然后在我们的控制台中就可以看到我们%s的地方变成了name储存的变量。如果我们变量是其他类型，我们的S就要相应的改变。
  接下来我们看看整数型的格式化输出：id = 11111111
                                                                  print("我的学号时%d"%id)
我们就可以在控制台中看到我们的输出语句：我的学号是时1111111
后面的浮点型，和其他都是相同的，还有一个小细节：我们如何输出% 我们需要输入两个%就可以输出了。
  id_2 = 60
print("我的成绩是全班的前%.2f%%"%id_2)，其中我们的.2表示小数点后还有两位数，所以这段话，我们输出的结果就是60.00%

变量的命名：

标识符和关键字：标识符就是程序员定义的变量名， 标识符需要有见名知义的效果，可以用字母、下划线、数字组成。但是不能用数字开头，并且不能和关键字重名

关键字就是Python的内部已经使用的的标识符，具有特殊意义和含义，所以我们不能够和关键字重名，我们使用import keyword print(keyword.kwlist)就可以查看我们的python已经使用了那些关键字。          我们在给变量起名字的时候用下划线来分隔单词，当然也可以用大驼峰和小驼峰来进行命名。例如我们定义学校名称：school_name = “ ”这样命名可以使我们的代码看起来易懂。

我们接下来认识一个判断语句，分支语句——（if）语句：

if的格式先写一个if，然后要判断的代码，加一个冒号。下一行就要按4个空格，也就是一个tab键，如果使用ide的话就会自动帮你缩进。我们在开发的时候要记住，要把if下方缩进的部分看做一个代码块。下面就是我的一个简单的判断语句，如果age大于等于18我们就显示可以进网吧happy

![1575461168367](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575461168367.png)

下面我给大家看一个代码：

![1575462291038](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575462291038.png)

当我们的条件不满足if的时候我们就不会再看if后面缩进的语句，而是直接运行我们的顶格写的输出函数，简单地说，就是条件成立就运行我们缩进的代码，如果不成立就直接运行顶格写的代码，这就是if的判断句。接下来我们来看条件不成立的时候执行代码利用else关键字来进行不满足条件的输出，格式为else:

![1575463113755](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575463113755.png)

使用else的时候 一定要配合if的条件来使用。

我们将程序增强：



![1575463395959](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575463395959.png)

这样我们就可以控制用户的输入然后进行if的判断，这里有一个小细节，我们的input函数的输出是字符串的格式，所以我们要用int()函数强制转换，因为我们比较的时候需要同一种类型。同理我们也可以吧if语句的判断条件改为字符串。

![1575463644134](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575463644134.png)

但是在我们实际开发的时候，并不会只有一个判断，这个时候我们就需要认识逻辑预算，什么是逻辑运算呢？就是说我们的条件不止一个，例如成年男性，我们就需要判断两个条件，年龄和性别，我们就需要用到逻辑运算符号，在Python中有三个运算符号：与 and/或 or/非 not  接下来我们看看这段代码：

![1575465424094](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575465424094.png)

我们在这段代码的if判断位置多加了一个判断，就形成了一个逻辑判断语句，这是当我们输入 22 和 男 的时候符合我们的判断条件，就直接执行我们的代码块中的内容，接下来看or的使用，or只要有一个成立就算成立。我们设计代码来判断两门中的某一门是否大于等于60，只要有一个满足我们就可以输出考试通过，没有一个吻合的话就输出考试失败，下次努力。

![1575543675799](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575543675799.png)

这就是or的逻辑运算符的用法，只要我们的判断条件一个满足就可以执行下面的代码块。

接下来轮到not这个逻辑运算符号：

首先我们定义一个布尔型变量来判断是否是我们学校的学生，首先我们的bool的值为False，利用if加上not来判断：如果这个bool值等于Ture，就不输出任何东西，如果是False就输出不是我们学生。

![1575544528246](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575544528246.png)

not在开发的时候多用于只希望一些不满足的时候执行代码，其次在拼接复杂的逻辑代码时也会用的到。

然后我们学习下一elif，我们利用这个来处理我们没有判断到的条件，比如if和else只能判断是或非，如果我们的判断不仅一个的时候，怎么办？就可以使用elif来进行多次判断

我们设计一段代码来判断成绩的等级：0-60分为差、60-80分为良、80-100分为优秀，我们输入成绩来确定等级：

![1575545463903](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575545463903.png)

elif的使用格式基本和if的相同，所以我们会使用if，就会使用elif，并且我么的elif是要和if一起用的。

if的嵌套：

if的嵌套和我们学习的elif有什么区别和相同点和不同点呢？首先我们先了解什么是if嵌套，所谓的if嵌套就是在if的代码块中还存在if，这种嵌套是有先后顺序的，比如我们要判段我们带刀上火车是否可以通过安检，我们首先判断是否有票，然后在判断刀的长度，超过20的就不能通过安检，接下来看看我们的代码：



![1575549623735](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575549623735.png)

我们定义一个bool来判断是否有票，要是有的话就执行我们的下一个判断，来判断刀的的长度，这就是我们的if嵌套。简单来说就和上大学一样，先看你成绩够不够，够了再选专业，如果分数不够的话，就直接拒之门外。

随机库：利用import 来使用随机库random，我们要生成一个1-100的随机数应该构建：

![1575629689209](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575629689209.png)

这样我们每次运行的时候都会给我们随机分配一个随机数。



程序的三大流程，顺序、分支、循环，顺序就是python的解释器一条一条的解释代码，分支就是我们的判断语句，然后最后一个循环，就是我们的最后一个：

循环就是让特定的代码 重复执行。首先我们来了解while这个循环：我们在定义循环的时候，一般需要定义一个计数变量，一般的都是用” i = 0 和while <= 我们定义的循环次数 “ 来使用

我们设计一个代码让我们的打印hello次数，次数由我们自己确定：

![1575631865237](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575631865237.png)

接下来我们来看braek和contiune这两个函数：break的作用是：当某一个条件满足的时候就不在执行其他重复执行后面的代码，contiune的作用是：当某一条件满足时，不执行后续重复代码，这两个函数只在单当前的循环中起作用。

break：

![1575701361689](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575701361689.png)

当我们的i自增到3以后，便执行我们的break跳出循环：

![1575701416686](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575701416686.png)

这就是break的作用

接下来看contiune：

![1575702977003](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575702977003.png)

这一段代码的最后结果是输出0-9，但是在输出3 的时候把3换成了遇到三，我们的comtiune和break最大的区别就是一个是直接碰到就退出循环，另一个就只是退出满足当前条件的那一个。



while循环的嵌套，和if一样，就是在while里面还有一个while：这里我们有一个小细节，就是我们的print（）函数他是会自动帮我们换行的，就是我们输出的语句最后面会加上一个/n，但是有些时候我们不想要换行，所以我们就需要使用”end = “ ” “，这样我们就可以把后面的print输出的内容放在同一行输出来：

![1575703997503](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575703997503.png)

![1575704040425](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575704040425.png)

这是没有用任何连接两个print的方式，如果我们想要用其他符号来连接的话就需要在end的后面引号中添加我们想要的符号：

![1575704222253](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575704222253.png)

我们使用了and来连接这三个字符串，你可以使用任何一个符号来连接。

接下来我们看到输出5行* 并且每一行的数量和当前行数相同的程序：

![1575706436610](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575706436610.png)

首先我们先要把我们的计数的循环加上，row为循环的次数，我们可以观察发现，每一行的 *数量和我们行数是一样的，所以我们来嵌套一个循环来记录行数，我们多少行，就输出多少次符号，当我们第一次while循环的时候我们直接输出一个星，因为我们用了end所以要在这个外面循环加一个换行，不然就会输出一排猩猩：

![1575707899807](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575707899807.png)加上的话就不会有这问题：

![1575707992185](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575707992185.png)

这样我们就输出了5行猩猩



接下来我们来做九九乘法表，首先我们先把我们的每一个公式看做一个*我们来输出这符号，利用我们的while循环：

![1575715159987](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575715159987.png)

这样我们就把每一行的公式用*表示出来了，现在我们就要把每一个符号变成我们的公式，我们知道第一行的公式是 1x1=1第二行是2x1=2 ，2x2=4我们可以发现规律，我们的每一行的公式数等于行数，每一列的列数x当前我的行数就是我们的公式，所以我们修改一下代码：

![1575715468614](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575715468614.png)

这样我们就将我们的乘法表输出了，但是我们可以发现我们的乘法表没有对齐，所以我们就要想办法对齐，那么接下来，我们就来了解一下转义符号：

 ![点击查看源网页](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3139807287,845943842&fm=11&gp=0.jpg) 

首先我们来看\t：这个转义符号我的意思是输出文本是，保持垂直对齐，比如我们在我们的九九乘法表中执行:

![1575716230867](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575716230867.png)

这样就能够让我们的输出变得美观。

![1575716287685](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575716287685.png)

然后看到我们的下一个转义：\n：这个符号是用来在控制台输出一个换行符，比如我们在输出：

hello python的时候在中间加一个\n就可以让这两个单词换成两行输出：

![1575716528798](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575716528798.png)

这就是这个转义的作用，我们如果要输出一个双引号的话也是一样的用一个\就可以输出了：

![1575716998957](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575716998957.png)



接下来，我们来了解函数：

函数的作用是将我们的代码块封装起来，在我们使用的时候就调用它，我们函数的定义规则为：

def 函数名()：

其中我们def是英文define的缩写，函数我的名要能够准确的表达我们的代码的功能，方便调用，函数的名称要符合命名规则，不能够和关键字重名，不能够数字开头，我们定义好函数只表示我们封装了这一段代码而已，不调动的话直接运行是不会有结果的。如果我们要调用，直接输入函数名加（）就可调用， 我们接下来定义一个打招呼的函数并调用它：

![1575890668588](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575890668588.png)

这样我们就简单的上手我们的第一个函数。

我们调用函数的时候一定要先定义在调用，如果我们调用后定义的话，就没办法做到调用的过程，在开发的过程中可以使用注释来解释我们的模块，这里有一个细节我们在定义函数的时候要在我们的def上方保留两个空行，这样可以保证我们的代码规范，我们注释的时候就在我们的代码下方使用三个单引号来注释如下：

![1575893896827](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575893896827.png)

然后我们就可以使用快速查看，看到我们函数的定义，首先点击我们调用函数的那一行，然后点击View 然后点击第三个就可以查看了：（也可以使用ctrl+Q快速查看）

![1575893994795](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575893994795.png)

![1575894210191](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575894210191.png)

接下来我们来看看函数的参数：

参数就是我们在使用函数的时候，把我们想要输入的值传到我们定义的函数里面进行使用，这样可以提高我们函数的灵活性。

函数的传参要在我们的函数名后面的小括号里，填写我们的参数用逗号隔开就可以了，比如我们的计算两个数字的和的函数：

![1575895272138](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575895272138.png)

这样的话我们只能够计算固定的10+20 的值，不能进行其他的计算，我们在定义参数的时候就可以直接把我们的变量名放在我们定义函数的小括号里就可以设置我们想要的参数计算了，记住我们的参数顺序就是我们输入参数的顺序：

![1575896296530](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575896296530.png)

函数有了参数后就增加了我们函数的通用性，让我们的函数能够针对相同的处理逻辑处理更多的数据。

针对参数我们来看看形参和实参：

我们在调用函数的时候，传递的参数的参数是: 实参；我们在定义函数使用参数是形参。

实参：通俗的说就是实实在在的参数，因为我们实参就是传递的我们输入的数据，是存在的

形参：就是为了让这个函数接收外部的数据，我们只有定义了这个形参才能够传递我们的实参：

![1575897169664](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575897169664.png)



函数的返回值：

我们的函数封装了我们的代码，我们在调用以后希望可以还告诉我们的用户，我们使用了这个函数做了些什么，以便我们的后续操作，就可以加一个返回值：

![1575898338548](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1575898338548.png)

我们使用了return来返回我们的计算值，这就是我们的参数返回值调用的时候我们直接使用变量来接收返回的结果。

return表示返回，如果我们使用了return的话在后续的代码均不会被识别，也不会执行。

接下来看函数我的嵌套：

函数的嵌套就是在一个函数里面嵌套另外一个函数：

我们首先定义一个函数来打印一行分割线，并且我们能够自定义函数的行数和符号，如下：

![1576041741052](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576041741052.png)

这样我们就可以直接通过传参的方式来打印一行：

![1576041855768](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576041855768.png)

这样我们就做到了我们的要求，答应了一百次*号，接下来我们增加以下我们的需求，要求我们一下打印5行我们的分割线，这个时候我们就可以使用函数的嵌套，定义一个函数，然后把我们定义的打印一行的函数执行5次就可以做到了，如下：

![1576042075970](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576042075970.png)

这样我们就可以完成我们的要求，并且我们也使用了函数的嵌套。

我们知道使用三对引号可以对我们的函数做注释，使用热键就可以看到我们的函数的描述，那么我们怎么样对形参做注释呢？

当我们将我们的鼠标移动到我们的函数名上时，我们就可以看到我们的前面有一个小灯泡：

![1576042964312](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576042964312.png)

打开以后我们选择第二个：

![1576042989295](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576042989295.png)

他就会在我们的代码中帮我们添加注释的格式：

![1576043033337](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576043033337.png)

然后我们依次填入我们的注释，就可以使用快捷键将我们所有的注释显示出来，可以显示函数的注释，也可以显示我们形参的注释：

![1576042863553](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576042863553.png)

这样就利用文档注释将我们的函数注释好了。



接下来我们来针对模块进行讲解：

模块是我们Python程序的核心，模块就像一个工具包，当我们想使用模块中的工具时，我们就要导入这个模块，每一个以py结尾的源码文件，都是模块，模块中定义的全局变量，函数都是模块能够给外部提供的直接使用的工具。

首先是模块名：我们在给文件起名字的时候也是一个标识符，我们命名的规则和前面的一样，不能以数字开头，不能和关键字重名，使用下划线和字母数字组成，接下来我们将我们的打印分割线的函数打包为模块，起名为mk_打印模块.py ：

![1576048241915](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576048241915.png)

我们在创建一个体验模块来使用我们的函数，这样我们就可以利用import来使用我们的模块：

![1576048320718](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576048320718.png)

当我们在模块后面加上一个.的时候就会出现我们这个模块里面玩的函数注释，不难看出，我们的模块里面有两个函数，一个是print_line  和 print_lines，我们就可以使用这个模块来打印我们的分割线了：

![1576048695202](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1576048695202.png)

我们可以使用这两个模块的函数来进行打印我们的分割线，这就是我们这个模块是的使用。所有定义的函数都可以直接在外部使用，在这里我顺便提一下pycach目录，这个是我们编译过的文件，也就是我们的二进制文件，我们运行这样的文件会快的多。我们一般自己写的模块就被自动的转换为二进制文件pychan

列表的定义:
lis(列表)：是python中使用最频繁的数据类型，在其他的高级语言里面称为数组，它是用来专门存储一串信息，我们使用" [ ] "来定义我们的列表，元素之间使用逗号分隔开来，在这里我需要提醒一下，我们的程序中的索引第一位数字不是以 1 开头，而是0开头。索引就是数据在列表中的位置编号，我们刚刚说的排序就是这样的，我们的第一个数据的编号是0，第二个是1... 我们取值的时候超出数据的范围就会报错。

![1577012676970](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577012676970.png)

我们在ipython中来定义一个一个列表，来记录我们的学生名册：
![1577013353032](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577013353032.png)

可以看出我们的第一条数据小明的下标为0,在下面就是对列表的所有操作，我们来试试其中的一些命令。

![1577427125698](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577427125698.png)

现在我们可以创建一个列表，添加数据，上面所以写的所有对列表的操作，都是基于表存在的结果，所以在进行操作前需要创建一个列表，创建好以后就可以使用对应的语法，首先来使用增加数据：
他的语法为：

```python
name_list.insert(增加的下标,"增加的数据")
```

![1577427857748](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577427857748.png)

在第一个name_list 的基础上，添加下标的位置为3，数据为“老李”，在打印name_list 就成功的添加了数据，对应添加就有删除的选项，还是使用这个列表进行操作：删除的语法为：

```python
del name_list[0] 
```

![1577428190287](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577428190287.png)

按照我们的语法成功的删除了下标为0的数据“张山”，再来进行修改数据的操作：他的语法为：

```python
name_list [1]= "小刘"
```

![1577428593488](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577428593488.png)

果不其然，王五成功的修该为了老李。在所有的增删改除中，除了增，其他的都不能超过我们的下标位数，就是不存在的不能够使用。再来看到统计的语法：

```python
len(name_list)
```

![1577428837961](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577428837961.png)

可以看到输出的长度为3，最后我们来看一下排序：
  排序是我觉得很实用的一种语法，因为当初我学习的时候就是使用了下标的方法来进行反转排序输出，简单的来说就是倒着排然后愣是几天都没搞明白，现在想想确实是太呆了。
  先看到第一个升序排序：语法为

```python
name_list.sort()
```

![1577429589632](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577429589632.png)

使用了排序的语法以后，所有的数据都进行了升序的排序，在这里我们使用在这个语法的时候可以使用热键查看这个函数的意义：
![1577429743467](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577429743467.png)

这个模块有三个参数可以使用，self先不用搭理他，在后面的面向对象会使用到这个参数，下一个为key，这个是字典的相关操作，也不用管他，最后一个是reverse，他的意思是反转，这里我们就可以设置他的值为True ，就可以反转我们的排序，即降序排序，默认的是false 。知道这个以后我峨嵋你就来使用参数reverse来进行降序排序：语法为：

```python
name_list.sort(reverse = True)
```

![1577430043008](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577430043008.png)

name_list的元素就被降序排列了。

![1577430196993](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577430196993.png)

nun_list的元素也是，在使用了降序升序排列以后，再来使用反转的方法对列表来进行操作：
语法为：

```python
name_list.reverse()
```

![1577430697145](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577430697145.png)

reverse()模块只有一个self参数，我们就不用管他，可以看到现在的列表和原来的列表刚好相反，这就是反转语法的作用。也叫做逆序，其他的语法我就不在多写，按照上文的语句就可以使用了

## 元祖：

元祖和列表一样，都是用来存储数据的容器， 不同的地方在于元祖的数据是不能够进行修改的，也就是创立以后就不能够该，只能删除。元祖表示多个元素组成的序列，使用（）来定义。知道这些就来定义元祖：
![1577960837042](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577960837042.png)

元祖和列表相同的使用下标切片来获得数据，报错索引也是一样的。接下啦我们来看一下怎么定义只有一个元素的元祖：
![1577961201354](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577961201354.png)按照定义来的话可以发现，数据类型并不是我们想要的tuple类型，而是一个数字型，要想得到一个元祖型的话，需要使用逗号来进行定义：
![1577961453641](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577961453641.png)

关于元祖的操作在ipython中使用.＋tab键来查看这个函数的一些信息：
![1577961740271](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1577961740271.png)

可以使用cont和index两种方式对元祖进行操作count用来判断我们所查询的字符出现的次数。index用来判断我们查询的字符下标位置：


![1579445247264](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579445247264.png)

当然也可以使用len来判断元祖的长度。在开发的过程中我们不会对元祖进行遍历，因为不方便，元祖的存储数据大部分都不是相同的，所以我们一般不会使用元祖遍历和格式化输出。

元祖的应用场景：
函数的参数和返回值，是一个函数接收多参数和返回多参数；格式化字符串，格式化字符串后面的（）实际上就是一个元祖；让列表不可以被修改保护数据的安全



### 格式化字符串输出：

![1579447208175](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579447208175.png)

![1579447031162](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579447031162.png)

在使用格式化输出的时候不难看出，在%号后面的那一部分是一个元祖，这边是元祖的格式化输出的使用

### 元祖和列表的转换：

语法为：

```python
list(你定义的元组)
```

```python
tuple(你定义的列表)
```

![1579447735075](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579447735075.png)

## 字典的使用：

在讲解之前我们先来了解列表和他的区别：
列表是有序的对象集合；字典是无序的对象集合；在查字典的时候需要使用索引，也就是告诉我们你要查的东西在哪里，在python中字典把这个称为键值对，在下图我们形象的了解一下：

| key(键) | value(值) |
| ------- | --------- |
| name    | 小明      |
| age     | 18        |
| sex     | man       |

在这个表格中键就是name，age，sex这三个，所以他们也一一对应三个值。这就是所谓的键值对。字典的语法为：

```python
dir = {"key":"value","key2":"value2"}
```

字典中使用：一一对应键值，使用逗号来分隔不同的键值对，键必须要唯一，值可以为任何类型，但是键只能是字符串，数字或者元祖，字典是除了列表以外最灵活的数据类型，在使用输出函数输出的时候，输出的顺序和定义的顺序往往是不大相同的 

### 字典的操作：

### 取值：语法为

```python
print(dict{"key"})
```

![1579454839253](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579454839253.png)

key值为你自己想要查询的key，可以查到对应key值的value。但是前提要有对应得key

### 增：语法为

```python
dict["key"] = "value"
```

![1579455167237](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579455167237.png)

修改的语法和这个一样，如果你的key存在将你要修改的值填上就可以了：
![](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579455277354.png)

### 删除：语法为

```python
dict.pop("key")
```

![1579455584182](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579455584182.png)

如果你的值不存在，那么就会报错

### 其他方法：

统计键值对的数量：语法为

```python
len(dict)
```

合并字典：语法为：

```python
dict.update(dict2)
```

这个语法是吧dict2加到dict中，如果合并的字典中包含已存在的key，就会直接覆盖值

清空字典：语法为：

```python
dict.clear()
```

![1579456325705](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579456325705.png)

在开发的过程中，我们最多的使用的是列表和字典的共同使用来描述更复杂的信息

![1579456652900](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579456652900.png)

#### 对字符串的常用操作：

l

```python
len(str)#统计字符串长度
str.count#统计出现的次数
str.index #统计第一次出现的位置

```

![1579485510940](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579485510940.png)

字符串的常用方法 

#### 判断类型：

```python
str.isspeace() #判断是否只包含空格
str.isalnum() #判断是否都是数字或者字母
str.isalpha() #判断是否全部都是字母
str.isdecimal() #判断是否全部是全角数字
str.isdigit() #判断只包含全角数字
str.numeric() # 判断是否值含有全角数字和汉字数字
str.istitle() #判断是否为标题化（每一个单词的首字母为大写）
str.islower() # 判断是否都为小写字符
str.isupper() #判断是否全部为大写
```

 

#### 查找和替换：

```python
str.startswith("str") #检查字符串是否以输入的str开头
str.endswith("str") #检查是否以指定的字符串结尾
str.find(str,start=0,end=len(str)) #检查特定的字符在某个范围中，如果不存在就返回-1，不会像index一样报错
str.rfind(str,start = 0 ,end =len(str)) #和find相似，但是是从右边开始检查
str.lfind(str,start = 0 ,end =len(str)) #和find相似，但是是从左边开始检查
str.replace(old_str,new_str,num=str.count(old_str))#把str中的old_str替换为new_str，num指定的话，就不会超过num的次数

```

#### 大小写转换：

```

```

#### 文本对齐：

```python
str.ljust(width) #统一输出一段文字，保证他们输出的结果向左对齐，默认使用半角空格，但是使用全角空格比较好，因为跨度大
str.rjust(width)# 和上面一样，只是对齐方向为右边（既靠在右边的字符对齐）
str.center(width) # 居中对齐

```



#### 去除空白字符：

```python
str.lstrip() # 去除字符串左边的空格
str.rstrip() # 去除字符串右边的空格  
```

#### 拆分和连接：

```

```

### 字符串的切片：

首先切片适合字符串，列表，元祖，他们都是有序集合所以可以进行切片的操作，通过索引值来进行操作，字典是键对值，所以不能够使用切片。索引就是一个标记，比如“你好，我的朋友”这句话，他的第一个字“你”的下标索引为0，不需要问为什不是1，因为在计算机中定义了就是0，然后第二个字符“好”的下标索引值就是1，依次类推

字符串的切片就是在这个基础上进行的，下面是他的语法：

```python
str[开始索引的下标位置:结束索引的下标位置:步长]
```

其中在结束索引的切片位置是不会将这个位置的字符包含在取值里面的，所谓的步长就是我们每一次取了以后间隔多少个字符串再取的新的字符
![1579532490527](C:\Users\15749\AppData\Roaming\Typora\typora-user-images\1579532490527.png)

在对较长的字符串就使用倒取得字符切片，在Python中定义最后一个字符的下标为-1，然后倒数第二个依次递减为-2、-3...。所以结束位置的下标可以直接用-1代替。



### 高级数据的公共方法：

#### python的内置函数：

内置函数就是不需要使用import调用，直接使用的函数。包括余下：


```python
len() # 计算容器中的元素个数
del() # 删除变量，也可以用来删除容器中的指定元素：del list[0] 
max() # 返回容器中最大的元素
min() # 返回容器中最小的元素（包括字母），比较字典的时候是比较key的大小
cmp(a.b) # 比较两个值（python3.0取消了这个函数），在3.0中直接使用运算符号比较，字典无法比较
```

#### 切片：

不过多说，懂得都懂，字典不支持切片

#### 运算符

加、乘、in 、 not in 、>>=、 ==、 <<=

在高级数据中，字典没有办法使用乘号，因为字典的key值要唯一，其他的都可以使用乘号

加号：加号和list.extend的方式区别是，加号会创建新的列表，而extend在原来的里面加上就是，append的方式会把要加入的列表当做一个元素来加入：





in not in：成员运算符号：

```python
item in [] or () 

```

表示某个元素存在在于在这个集合总

```python
item  ont in [] or () 
```

表示某个元素是否存在于在这个集合总